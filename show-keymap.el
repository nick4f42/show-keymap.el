;;; show-keymap.el --- Textual keyboard display of keymaps -*- lexical-binding:t -*-

;; Copyright (C) 2024 Nick OBrien

;; Author: Nick OBrien <nick4f42@proton.me>
;; Created: 2024
;; Homepage: https://github.com/nick4f42/show-keymap.el
;; Keywords: help
;; Package-Version: 0.1.0

;; This file is NOT part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;;; Code:

(defgroup show-keymap nil
  "Textual keyboard display of keymaps."
  :group 'help
  :prefix "show-keymap-")

(defcustom show-keymap-hidden-commands
  '(undefined self-insert-command digit-argument)
  "Commands to hide in the *show-keymap* buffer."
  :type '(repeat symbol))

(defcustom show-keymap-keyboard 'show-keymap-layout-box
  "Keyboard string to show in the *show-keymap* buffer.
Each key is specified by giving a portion of the string the
`show-keymap' property, which is a plist with the following
properties:

`basic-type'
  The basic type of the event generated by pressing the key as
  returned by `event-basic-type', or nil if not applicable.

`basic-type-shift'
  The basic type of the event generated by shift-pressing the key, or
  nil if not applicable.

`shift'
  An optional cons (INDEX . STRING) that specifies to replace the text
  starting at INDEX with STRING when the shift modifier is active.

`modifier'
  The event modifier that the key generates as returned by
  `event-modifiers', or nil if not applicable."
  :type 'variable)

(defgroup show-keymap-faces nil
  "Faces used by `show-keymap'."
  :group 'show-keymap
  :group 'faces)

(defface show-keymap-keyboard-face
  '((t :inherit default))
  "Face used for the keyboard.")

(defface show-keymap-key-face
  '((t :inherit shadow))
  "Face used for unbound keys.")

(defface show-keymap-key-mouse-face
  '((t :inherit show-keymap-key-face))
  "Face used for mouse-hovered unbound keys.")

(defface show-keymap-modifier-face
  '((t :inherit highlight))
  "Face used for active modifier keys.")

(defface show-keymap-modifier-mouse-face
  '((t :inherit show-keymap-modifier-face))
  "Face used for mouse-hovered active modifier keys.")

(defface show-keymap-command-face
  '((t :inherit highlight))
  "Face used for keys that are bound to commands.")

(defface show-keymap-command-mouse-face
  '((t :inherit show-keymap-command-face))
  "Face used for mouse-hovered keys that are bound to commands.")

(defface show-keymap-map-face
  '((t :inherit query-replace))
  "Face used for keys that are bound to prefix keymaps.")

(defface show-keymap-map-mouse-face
  '((t :inherit show-keymap-map-face))
  "Face used for mouse-hovered keys that are bound to prefix keymaps.")

(defvar-keymap show-keymap-mode-map
  :doc "Keymap for Show Keymap mode."
  :parent (make-composed-keymap button-buffer-map special-mode-map)
  "l" 'show-keymap-history-back
  "r" 'show-keymap-history-forward
  "C-c C-b" 'show-keymap-history-back
  "C-c C-f" 'show-keymap-history-forward
  "<XF86Back>" 'show-keymap-history-back
  "<XF86Forward>" 'show-keymap-history-forward)

(defvar show-keymap--buffer-name "*show-keymap*")

(defvar-local show-keymap--keymap nil
  "Describes how to look up key bindings.
Can either be a keymap or a function, see `show-keymap--lookup'.")

(defvar-local show-keymap--prefix nil
  "The binding corresponding to `show-keymap--keymap'.
Must be a string that is empty or satisfies `key-valid-p'.")

(defvar-local show-keymap--modifiers nil
  "List of the active modifiers on the displayed keyboard.
Same format as `event-modifiers'.")

(defvar-local show-keymap--history nil
  "List of `show-keymap--state' to move backward to.")

(defvar-local show-keymap--history-forward nil
  "List of `show-keymap--state' to move forward to.")

(define-derived-mode show-keymap-mode special-mode "Show Keymap"
  "Major mode for showing key binds on a textual keyboard.

Key bindings:
\\{show-keymap-mode-map}"
  :group 'show-keymap
  (setq truncate-lines t))

;;;###autoload
(defun show-keymap (keymap prefix key)
  "Show a keymap on a textual keyboard.
Interactively, prompt for a key bind and show the keymap that it
belongs to.

If KEYMAP is a keymap, use it as is.  If it is nil, use the
prefix keymap bound to PREFIX, or use all active keymaps if
PREFIX is the empty string.  KEY is an event that gives the
modifiers to display on the keyboard.  Both PREFIX (unless empty)
and KEY must satisfy `key-valid-p'.

For example, (show-keymap nil \"C-c\" \"C-a\") displays bindings
in all active keymaps that start with \"C-c\" and end with a
control-modified event."
  (interactive
   (let* ((cursor-in-echo-area t)
	  (keys (read-key-sequence "Keys: "))
	  (prefix (key-description (seq-subseq keys 0 -1)))
	  (key (key-description (seq-subseq keys -1))))
     (list nil
	   prefix
	   key)))
  (unless keymap
    (setq keymap
	  (if (string-empty-p prefix)
	      ;; Look up keys using the current active maps of this
	      ;; buffer, not the show-keymap buffer.
	      (let ((b (current-buffer)))
		(lambda (&rest args)
		  (with-current-buffer b
		    (apply #'keymap-lookup nil args))))
	    (or (key-binding (key-parse prefix))
		(error "Unknown prefix key binding")))))
  (with-current-buffer (get-buffer-create show-keymap--buffer-name)
    (unless (eq major-mode 'show-keymap-mode)
      (show-keymap-mode))
    (let ((parsed (seq-first (key-parse key))))
      (show-keymap--reset keymap prefix
			  (event-modifiers parsed)
			  (event-basic-type parsed)))
    (pop-to-buffer (current-buffer))))

(defun show-keymap-history-back ()
  "Go to the previous keymap in this buffer."
  (interactive nil show-keymap-mode)
  (or show-keymap--history
      (user-error "This is the first keymap you looked at"))
  (when-let ((state (show-keymap--state)))
    (push state show-keymap--history-forward))
  (seq-let (keymap prefix modifiers) (pop show-keymap--history)
    (show-keymap--reset keymap prefix modifiers nil t)))

(defun show-keymap-history-forward ()
  "Go to the next keymap in this buffer."
  (interactive nil show-keymap-mode)
  (or show-keymap--history-forward
      (user-error "This is the last keymap you looked at"))
  (when-let ((state (show-keymap--state)))
    (push state show-keymap--history))
  (seq-let (keymap prefix modifiers) (pop show-keymap--history-forward)
    (show-keymap--reset keymap prefix modifiers nil t)))

(defun show-keymap--state ()
  (if show-keymap--keymap
      (list show-keymap--keymap show-keymap--prefix show-keymap--modifiers)))

(defun show-keymap--reset (keymap prefix modifiers &optional basic-type no-history)
  "Update the `show-keymap' buffer to a new keymap."
  (when-let (((not no-history))
	     (state (show-keymap--state)))
    (seq-let (old-keymap old-prefix _) state
      (unless (and (eq keymap old-keymap)
		   (equal prefix old-prefix))
	(push state show-keymap--history))))
  (setq show-keymap--keymap keymap
	show-keymap--prefix prefix
	show-keymap--modifiers modifiers)
  (let ((buffer-read-only nil)
	(opoint (point))
	(shift (memq 'shift modifiers))
	keyboard-end)
    (remove-overlays)
    (erase-buffer)
    (insert (symbol-value show-keymap-keyboard))
    (setq keyboard-end (point))

    (goto-char (point-min))
    (when (and basic-type
	       (text-property-search-forward
		'show-keymap
		basic-type
		(lambda (value prop-value)
		  (equal value (plist-get prop-value 'basic-type-shift)))))
      (setq shift t)
      (push 'shift modifiers))

    (goto-char (point-min))
    (let (defs)
      (while-let ((match (text-property-search-forward 'show-keymap)))
	(let* ((start (prop-match-beginning match))
	       (end (prop-match-end match))
	       (props (get-text-property start 'show-keymap))
	       (basic-type (plist-get props 'basic-type))
	       (shift-key (plist-get props 'basic-type-shift))
	       (mod (plist-get props 'modifier))
	       keys def)
	  (setq keys
		(key-description
		 (vector (event-convert-list `(,@modifiers ,basic-type)))))
	  (or mod
	      (setq def (show-keymap--lookup keymap keys))
	      (if shift
		  (let ((shifted-keys
			 (key-description
			  (vector (event-convert-list
				   `(,@(delq 'shift (copy-sequence modifiers))
				     ,shift-key))))))
		    (if (setq def (show-keymap--lookup keymap shifted-keys))
			(setq keys shifted-keys))))
	      (when-let* ((bind (keymap-lookup local-function-key-map keys))
			  ((not (keymapp bind)))
			  (new-keys (key-description bind))
			  ((not (string-empty-p new-keys))))
		(setq keys new-keys
		      def (show-keymap--lookup keymap keys))))
	  (let* ((kmacro-p (and (fboundp 'kmacro-p)
				(kmacro-p def)))
		 (full-keys (if (string-empty-p prefix)
				keys
			      (concat prefix " " keys)))
		 (action
		  (lambda (_)
		    (cond (mod
			   (if (memq mod modifiers)
			       (setq modifiers (delq mod modifiers))
			     (push mod modifiers))
			   (show-keymap--reset keymap prefix modifiers))
			  (kmacro-p
			   (edit-kbd-macro (key-parse full-keys)))
			  ((functionp def)
			   (describe-function def))
			  ((keymapp def)
			   (show-keymap--reset def full-keys nil))))))
	    (when-let
		((shift)
		 (shift-info (plist-get props 'shift))
		 (index (car shift-info))
		 (shift-str (cdr shift-info))
		 (pos (+ (point-min) index)))
	      (let ((ov (make-overlay pos (+ pos (length shift-str)))))
		(overlay-put ov 'display shift-str)))
	    (cond
	     ((and def (memq def show-keymap-hidden-commands))
	      (add-text-properties
	       start end
	       `( face show-keymap-key-face
		  help-echo ,(format "`%s'" def))))
	     ((or def mod)
	      (apply
	       #'make-button start end
	       'action action
	       (cond (mod
		      (append
		       `(help-echo ,(format "toggle `%s'" mod))
		       (if (memq mod modifiers)
			   '( face show-keymap-modifier-face
			      mouse-face show-keymap-modifier-mouse-face)
			 '( face show-keymap-key-face
			    mouse-face show-keymap-key-mouse-face))))
		     ((keymapp def)
		      '( help-echo "show keymap"
			 face show-keymap-map-face
			 mouse-face show-keymap-map-mouse-face))
		     (t
		      `( help-echo ,(if kmacro-p "edit kmacro"
				      (format "describe `%s'" def))
			 face show-keymap-command-face
			 mouse-face show-keymap-command-mouse-face)))))
	     (t
	      (add-face-text-property start end 'show-keymap-key-face)))
	    (when def
	      (push (list keys
			  (cond ((keymapp def) "keymap")
				(kmacro-p "kmacro")
				(t def))
			  action)
		    defs)))))

      (setq defs (nreverse defs))

      (goto-char (point-max))
      (insert "\n")
      (unless (string-empty-p prefix)
	(insert (propertize (concat prefix "-") 'face 'help-key-binding)
		"\n"))
      (pcase-dolist (`(,key ,def ,action) defs)
	(unless (memq def show-keymap-hidden-commands)
	  (insert (propertize key 'face 'help-key-binding)
		  "  ")
	  (let ((start (point)))
	    (insert (format "%s" def))
	    (make-button start (point) 'action action))
	  (when (functionp def)
	    (when-let ((doc (documentation def)))
	      (when-let ((index (seq-position doc ?\n)))
		(setq doc (substring doc 0 index)))
	      (insert "  " (propertize doc 'face 'font-lock-doc-face))))
	  (insert "\n"))))
    (goto-char (min keyboard-end opoint))))

(defun show-keymap--lookup (keymap &rest args)
  "Look up a key binding."
  (if (functionp keymap)
      (apply keymap args)
    (apply #'keymap-lookup keymap args)))

(defconst show-keymap-default-keys
  '(("C-" . (control . nil))
    ("M-" . (meta . nil))
    ("S-" . (shift . nil))
    ("s-" . (super . nil))
    ("tab" . (nil . tab))
    ("ret" . (nil . return))
    ("bsp" . (nil . backspace))
    ("spc" . (nil . ?\s))
    ("menu" . (nil . menu))
    ("esc" . (nil . escape))
    ("prt" . (nil . print))
    ("slk" . (nil . Scroll_Lock))
    ("pau" . (nil . pause))
    ("ins" . (nil . insert))
    ("del" . (nil . delete))
    ("hom" . (nil . home))
    ("end" . (nil . end))
    ("pup" . (nil . prior))
    ("pdn" . (nil . next))
    ("←" . (nil . left))
    ("↓" . (nil . down))
    ("→" . (nil . right))
    ("↑" . (nil . up))))

(defconst show-keymap-default-shift-map
  '((?` . ?~)
    (?- . ?_)
    (?= . ?+)
    (?\[ . ?\{)
    (?\] . ?\})
    (?\\ . ?|)
    (?\; . ?:)
    (?\' . ?\")
    (?, . ?<)
    (?. . ?>)
    (?/ . ??)
    (?1 . ?!)
    (?2 . ?@)
    (?3 . ?#)
    (?4 . ?$)
    (?5 . ?%)
    (?6 . ?^)
    (?7 . ?&)
    (?8 . ?*)
    (?9 . ?\()
    (?0 . ?\))))

(cl-defun show-keymap-make-layout
    ( &key
      layout
      key-regexp
      (keys show-keymap-default-keys)
      (shift show-keymap-default-shift-map))
  "Create a string suitable for `show-keymap-keyboard'.
LAYOUT is a string to display as the keyboard.  KEY-REGEXP must
match in group 1 the regions in LAYOUT that correspond to
individual keys.  KEYS is an alist of (STRING . (MODIFIER
. TYPE)) where STRING is the text matched in group 2 of
KEY-REGEXP.  If the key is a modifier key, MODIFIER is the
modifier a la `event-modifiers' and TYPE is nil.  Otherwise,
MODIFIER is nil and TYPE is the basic type a la
`event-basic-type'."
  (let ((layout (copy-sequence layout))
	(key-event
	 (lambda (str)
	   (let ((case-fold-search nil))
	     (cond
	      ((string-match-p (rx bos
				   (any "a-z" "0-9" ?` ?- ?= ?\[ ?\]
					?/ ?\\ ?\; ?\' ?, ?.)
				   eos)
			       str)
	       (cons nil (aref str 0)))
	      ((string-match-p (rx bos "f" (+ digit) eos)
			       str)
	       (cons nil (intern str)))
	      ((alist-get str keys nil nil #'equal))))))
	(shift-map
	 (lambda (basic-type)
	   (if (characterp basic-type)
	       (cond ((string-match-p "[a-z]" (string basic-type))
		      (upcase basic-type))
		     ((alist-get
		       basic-type
		       shift))))))
	(start 0))

    (add-face-text-property
     0 (length layout) 'show-keymap-keyboard-face nil layout)

    (setq start 0)
    (while (string-match key-regexp layout start)
      (let* ((key (match-string 2 layout))
	     (event (funcall key-event key))
	     (modifier (car event))
	     (type (cdr event))
	     (shift (and type (funcall shift-map type)))
	     (index (match-beginning 2)))
	(add-text-properties
	 (match-beginning 1) (match-end 1)
	 `( show-keymap
	    ( modifier ,modifier
	      basic-type ,type
	      basic-type-shift ,shift
	      shift ,(if shift (cons index (string shift)))))
	 layout)
	(setq start (1+ (match-beginning 2)))))

    layout))

(defvar show-keymap-layout-box
  (show-keymap-make-layout
   :layout
   (string-replace "\\" " \\" "\
┌───┐ ┌───┬───┬───┬───┐  ┌───┬───┬───┬───┐  ┌───┬───┬───┬───┐┌───┬───┬───┐
│esc│ │f1 │f2 │f3 │f4 │  │f5 │f6 │f7 │f8 │  │f9 │f10│f11│f12││prt│slk│pau│
└───┘ └───┴───┴───┴───┘  └───┴───┴───┴───┘  └───┴───┴───┴───┘└───┴───┴───┘
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐┌───┬───┬───┐
│ ` │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 0 │ - │ = │  bsp  ││ins│hom│pup│
├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤├───┼───┼───┤
│ tab │ q │ w │ e │ r │ t │ y │ u │ i │ o │ p │ [ │ ] │ \\  ││del│end│pdn│
├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤└───┴───┴───┘
│ caps │ a │ s │ d │ f │ g │ h │ j │ k │ l │ ; │ ' │  ret   │
├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤    ┌───┐
│   S-   │ z │ x │ c │ v │ b │ n │ m │ , │ . │ / │    S-    │    │ ↑ │
├────┬───┴┬──┴─┬─┴───┴───┴───┴───┴───┴───┴─┬─┴──┬┴─────┬────┤┌───┼───┼───┐
│ C- │ s- │ M- │            spc            │ M- │ menu │ C- ││ ← │ ↓ │ → │
└────┴────┴────┴───────────────────────────┴────┴──────┴────┘└───┴───┴───┘
")
   :key-regexp
   (rx "│"
       (group (* blank)
	      (group (+ (not (any ?\n space ?│))))
	      (* blank))
       "│")))

(provide 'show-keymap)
;;; show-keymap.el ends here
